# Увод в програмирането със C++. Среда за разработка (IDE). Примитивни типове данни. Основни аритметични операции. Вход и изход. Условни оператори. Git и GitHub.

### Като за начало, да се запознаем със следните термини:

- **Програма** - редица от инструкции, които водят до решаването на конкретна задача.
- **Алгоритъм** - последователност от стъпки за решаване на проблем.
- **Компилатор** - инструмент, който превежда кода от програмен език (като C++) в машинен код, разбираем за компютъра.
- **Среда за разработка (IDE)** - инструмент за писане, тестване и дебъгване на програмен код

## Среди за разработка (IDEs)

### Какво е среда за разработка (IDE)?

Средата за разработка (IDE - Integrated Development Environment) е мощен софтуер, който предоставя всичко необходимо за разработване на приложения. Тя обединява редактор на код, компилатор, дебъгер и различни инструменти за управление на проекти, което значително улеснява работния процес на програмистите.

### Основни функции на IDE

- **Редактор на код**: Позволява ви да пишете и редактирате код с различни функции, като подсветка на синтаксиса, автоматично довършване и форматиране.
- **Компилатор**: Преобразува написания код в машинен код, който компютърът може да изпълнява.
- **Дебъгер**: Инструмент за откриване и поправяне на грешки в кода, който позволява наблюдение на променливи и стъпка по стъпка изпълнение на програмата.
- **Управление на проекти**: Организира вашите файлове и ресурси, за да улесни работата по проекти с множество компоненти.

### Популярни IDE-та за C++

- [**Visual Studio**](https://visualstudio.microsoft.com/downloads/)
- [**Visual Studio Code**](https://code.visualstudio.com/download)
- [**CLion**](https://www.jetbrains.com/clion/)

## Какво правят `#include` и `using namespace std`?

`#include` е директива в C++, която казва на компилатора да вмъкне съдържанието на друг файл в текущия файл преди компилирането. Това обикновено се използва за включване на библиотеки или хедър файлове, които съдържат елементи, нужни за нашата програма.

- Системни библиотеки

  ```cpp
  #include <iostream>
  ```

  Това указва на компилатора да търси файла в директориите за стандартни библиотеки. В случая с `#include <iostream>`, ние включваме библиотеката за вход/изход (Input/Output), която ни позволява да използваме cout, cin, и други подобни.

- Потребителски хедър файлове

  ```cpp
  #include "myHeader.h"
  ```

  Това казва на компилатора да търси файла първо в текущата директория на проекта. Обикновено се използва за включване на собствени файлове с код, написан от програмиста.

Когато пишем `using namespace std;` в C++, това означава, че казваме на компилатора да използва пространството от имена (namespace) std по подразбиране. Пространствата от имена се използват, за да групират имена на функции, класове и променливи, за да избегнем конфликти с други имена. В стандартната библиотека на C++ (Standard Library), много от използваните функции и обекти, като `cout`, `cin` и други, са дефинирани в пространството от имена std. Без `using namespace std;`, ще трябва всеки път да пишем:

```cpp
#include <iostream>

int main() {
    std::cout << "Hello, World!" << std::endl;
}
```

Иначе можем просто:

```cpp
#include <iostream>

using namespace std;

int main() {
    cout << "Hello, World!" << endl;
}
```

## Променливи и примитивни типове данни

Типовете данни определят каква информация може да бъде съхранена и манипулирана в програмата.

### Основни типове данни в C++

- int, short, long – цели числа
- double, float – числа с плаваща запетая
- bool – булев тип (true/false)
- char – символи

### Деклариране на променливи

```cpp
<тип на променлива> <име> = <стойност>;
```

Пример:

```cpp
int age = 20;
double temperature = 36.6;
bool isStudent = true;
char grade = 'A';
float grade = 5.5f;
```

### Преобразуване на типове данни

```cpp
int a = 10;
double aCopy = a; // 10.0

double pi = 3.14159;
int piCopy = pi; // 3 (има загуба на точност, понеже int е целочислен тип)

char c = 'A';           // Символ
int ascii = c;         // 65 (ASCII стойност на символa 'A')

float num = 9.99f;
int whole = num; // 9

int notZero = 5;     // Ненулево цяло число
bool b1 = notZero;    // true

int zero = 0;
bool b2 = c;    // false
```

## Стандартни потоци за вход и изход

`cin` (от "character input") е обект (поток), който се използва за получаване на вход от потребителя, в повечето случаи от клавиатурата.

`cout` (от "character output") е обект (поток), който се използва за извеждане на информация на конзолата.

### Пример за използване на `cin` и `cout`

```cpp
#include <iostream> // Включваме библиотеката, която съдържа cin и cout
using namespace std;

int main() {
    int age;
    cout << "Enter your age: ";    // Извеждане на текст
    cin >> age;                    // Вход на възраст

    // Изход на резултата
    cout << "Hello! You are " << age << " years old." << endl;

    return 0;
}
```

## Област на видимост на променливите (scope)

### Пример с еднакви имена на променливи

```cpp
#include <iostream>
using namespace std;

int x = 10; // Глобална променлива

int main() {
    cout << "Global x = " << x << endl; // 10

    int x = 20; // Локална променлива в main(), "скрива" глобалната x
    cout << "Local x in main = " << x << endl; // 20

    {   // Нов блок
        int x = 30; // Локална променлива в този блок, "скрива" локалната x в main()
        cout << "Local x in inner block = " << x << endl; // 30
    }

    cout << "Local x in main after block = " << x << endl; // 20 (локалната x в main())

    cout << "Global x accessed with :: = " << ::x << endl; // 10 (глобалната x чрез оператор ::)

    return 0;
}
```

### Пример с променливи, които не се виждат извън даден scope

```cpp
#include <iostream>
using namespace std;

int main() {
    int x = 10; // Локална променлива в main()
    cout << "x in main = " << x << endl; // 10

    {   // Начало на нов вътрешен блок
        int y = 20; // Локална променлива във вътрешния блок
        cout << "y in inner block = " << y << endl; // 20
        cout << "x in inner block = " << x << endl; // 10 (може да види x от main)
    }   // Край на вътрешния блок, y вече не съществува

    // Опит за достъп до y ще предизвика грешка, защото y е видима само във вътрешния блок
    cout << "y outside inner block = " << y << endl; // Грешка: y не е дефинирана в този scope

    return 0;
}
```

## lvalue и rvalue

**lvalue** - това е израз, който се намира отляво на операция за присвояване. Това са обекти в паметта, които имат постоянен адрес и могат да бъдат модифицирани, например променлива.

```cpp
int x = 10;  // 'x' е lvalue, защото има постоянен адрес в паметта
x = 20;      // Можем да присвояваме нови стойности на 'x'
```

**rvalue** - стойност, която се намира отдясно на операция за присвояване. rvalue са временни стойности, които нямат постоянен адрес и не могат да бъдат директно модифицирани. (константи, литерали, резултати от пресмятане)

```cpp
int x = 10;
int y = x + 5;  // 'x + 5' е rvalue - временно изчислена стойност
```

## Оператори

### Аритметични оператори

| Оператор |     Описание      | Пример | Резултат |
| :------: | :---------------: | :----: | :------: |
|    +     |     Събиране      | 5 + 2  |    7     |
|    -     |     Изваждане     | 5 - 2  |    3     |
|    \*    |     Умножение     | 5 \* 2 |    10    |
|    /     |      Деление      | 5 / 2  |    2     |
|    %     | Деление с остатък | 5 % 2  |    1     |

### Оператори за инкрементиране и декрементиране

Операторите за инкрементиране `++` и декрементиране `--` позволяват бързо увеличаване или намаляване на стойността на променлива. В зависимост от позицията им спрямо аргумента, те имат различно поведение:

- `++` преди променливата (prefix) - инкрементира стойността на променливата преди да бъде използвана, връща lvalue
  ```c++
  int a = 5;
  int b = ++a; // a = 6, b = 6
  ```
- `++` след променливата (postfix) - инкрементира стойността на променливата след като е била използвана, връща rvalue
  ```c++
  int a = 5;
  int b = a++; // a = 6, b = 5
  ```
- `--` преди променливата (prefix) - декрементира стойността на променливата преди да бъде използвана, връща lvalue
  ```c++
  int a = 5;
  int b = --a; // a = 4, b = 4
  ```
- `--` след променливата (postfix) - декрементира стойността на променливата след като е била използвана, връща rvalue
  ```c++
  int a = 5;
  int b = a--; // a = 4, b = 5
  ```

### Оператори за присвояване

| Оператор |  Пример  | Еквивалентен на |
| :------: | :------: | :-------------: |
|    +=    | m += 10  |   m = m + 10    |
|    -=    | m -= 10  |   m = m - 10    |
|   \*=    | m \*= 10 |   m = m \* 10   |
|    /=    | m /= 10  |   m = m / 10    |
|    %=    | m %= 10  |   m = m % 10    |

### Оператори за сравнение (_връщат булев резултат - true/false_)

| Оператор |      Описание       | Пример | Резултат |
| :------: | :-----------------: | :----: | :------: |
|    <     |      По-малко       | 1 < 2  |   True   |
|    >     |      По-голямо      | 1 > 2  |  False   |
|    <=    | По-малко или равно  | 1 <= 2 |   True   |
|    >=    | По-голямо или равно | 2 >= 2 |   True   |
|    ==    |        Равно        | 1 == 2 |  False   |
|    !=    |     Не е равно      | 1 != 2 |   True   |

!!! Не е препоръчително да сравняваме променливи от тип double с `==`, понеже стават грешки при представянето на числото в паметта заради закръгляне.

Вместо това въвеждаме константа EPSILON и проверяваме по следния начин:

```c++
#include <iostream>
#include <cmath>

using namespace std;

const double EPSILON = 1e-9;

int main() {
   double a = 0.1 + 0.2;
   double b = 0.3;

   bool areEqual = fabs(a - b) < EPSILON); //fabs е функция от cmath, която връща абсолютната разлика между две числа с плаваща запетая
   cout << areEqual;
}
```

### Логически оператори

| Оператор |    Описание     |     Пример      | Резултат |
| :------: | :-------------: | :-------------: | :------: |
|    &&    |  Логическо "И"  |  true && false  |  false   |
|   \|\|   | Логическо "ИЛИ" | true \|\| false |   true   |
|    !     | Логическо "НЕ"  |      !true      |  false   |

Съществуват и още оператори, с които ще се запознаете по - късно...

## Условни оператори

- `if`, `else if`, `else`

  ```cpp
  if (условие1) {
      // код, който да се изпълни, ако условие1 е истина
  } else if (условие2) {
      // код, който да се изпълни, ако условие2 е истина
  } else if (условие3) {
      // код, който да се изпълни, ако условие3 е истина
  } else {
      // код, който да се изпълни, ако нито едно от горните условия не е истина
  }
  ```

  Пример:

  ```cpp
  int a = 10;
  if (a > 10) {
      // няма да влезне тук, понеже a > 10 е false
      cout << "a is bigger than 10";
  } else if (a == 10) {
      // ще изпълни този код, понеже а == 10 e true
      cout << "a is equal to 10";
  } else {
      // няма да влезне тук
      cout << "a is smaller than 10";
  }
  ```

###

- `switch`

  ```cpp
  switch (променлива) {
      case стойност1:
          // код, който ще се изпълни ако променливата == стойност1
          break;
      case стойност2:
          // код, който ще се изпълни ако променливата == стойност1
          break;
      default:
          // код, който ще се изпълни, ако променливата не е равна на нито една от изброените горе стойности
  }
  ```

  Пример:

  ```cpp
  int number = 2;
  switch (number) {
      case 1:
          cout << "One";
          break;
      case 2:
          cout << "Two";
          break;
      case 3:
          cout << "Three";
          break;
      //...
      default:
          cout << "Something else...";
  }
  ```

  Лесно можем да се досетим, че този код ще принтира на конзолата "Тwo". Какво ще стане при следния код?

  ```cpp
  int number = 2;
  switch (number) {
      case 1:
          cout << "One" << endl;
      case 2:
          cout << "Two" << endl;
      case 3:
          cout << "Three" << endl;
      default:
          cout << "Something else..." << endl;
  }
  ```

  Резултат:

  ```
  Two
  Three
  Something else...
  ```

  !!! След като намери съвпадение с даден case, програмата продължава да изпълнява всички следващи блокове (включително тези на други case-ове), ако няма изрично break. Това поведение се нарича fall-through, което може да доведе до изпълнение на нежелан код!!!

  ###

- **тернарен оператор**

  ```cpp
  <условие> ? <стойност, ако е истина> : <стойност, ако е лъжа>;
  ```

  Пример:

  ```cpp
  int max = (a > b) ? a : b;
  ```

## Git и GitHub

_...ще бъде качено скоро..._
